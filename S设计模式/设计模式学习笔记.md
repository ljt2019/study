# 设计原则

不要为了套用设计模式而使用设计模式，而是在业务上遇到困难时自然而然地想到设计模式，做为一种解决问题的方案。

# 工厂模式

## 简单工厂模式

一个创建对象的接口，但让实现这个接口类来决定实例化哪个类，工厂方法让类的实例化过程推迟到类中进行

### 优点

1. 创建对象需要大量重复代码
2. 客户端(应用层)不依赖于产品类实例如何被创建、实现等细节
3. 一个通过其子类来指定创建哪个对象
4. 用户只关心所需产品对应的工厂，无需关心创建细节
5. 加入新产品符合开闭原则，提高系统的可扩展性

### 缺点

1. 类的个数容易过多，增加了代码结构复杂度
2. 增加系统的抽象性和理解难度

### 代码

~~~java
public class CourseFactory {

    public ICourse create1(String name) {
        if ("java".equals(name)) {
            return new JavaCourse();
        } else if ("python".equals(name)) {
            return new PythonCourse();
        } else {
            return null;
        }
    }

    public ICourse create(String className) {
        try {
            if (!(null == className || "".equals(className))) {
                return (ICourse) Class.forName(className).newInstance();
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public ICourse create(Class<? extends ICourse> clazz) {
        try {
            if (null != clazz) {
                return clazz.newInstance();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
~~~



## 抽象工厂模式

提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。
  1)、具体产品在应用层代码隔离，无需关心创建细节。
  2)、将一个系列的产品族统一到一起创建。
  3)、规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂接口。
  4)、增加系统的抽象性和理解难度。

3、单例模式：指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点
  线程模式打断点

#  单例

## 饿汉单例

首次加载时就创建实例，浪费内存空间，有点占着茅坑不拉屎的感觉，建议不要大量使用。

~~~java
package com.tiger.singleton;

/**
 * 饿汉式单例设计模式特点：线程安全、调用效率高、资源利用率低(无懒加载)。
 *
 * @author tiger
 * @Date 2017年9月2日
 */
public class SingletonHungry {
    /**
     * 私有化构造器
     */
    private SingletonHungry() {
    }

    //创建一个本类静态实例对象，static是天然的线程安全
    private static final SingletonHungry instance = new SingletonHungry();

    /**
     * 提供唯一一个外部可以访问本类的静态方法(访问本类的唯一入口)
     *
     * @return
     */
    public static SingletonHungry getInstance() {
        return instance;
    }
}
~~~

## 懒汉单例

并发效率低

~~~java
package com.tiger.singleton;

/**
 * 懒汉式单例设计模式特点：线程安全、调用效率低、资源利用率高(有懒加载)。
 *
 * @author tiger
 * @Date 2017年9月2日
 */
public class SingletonLazy {
    /**
     * 私有化构造器
     */
    private SingletonLazy() { }

    private static SingletonLazy instance = null;

    /**
     * 对方法进行同步（synchronized）并发效率低。
     * 防止一个线程执行到instance == null时挂起，这时而另外一个线程切进来执行完毕后，
     * 刚才挂起的线程又回来执行，这样就会出现多个个本类的实例，从而违背了单例设计的初衷
     */
    public synchronized static SingletonLazy getInstance() {
        if (instance == null) {
            instance = new SingletonLazy();
        }
        return instance;
    }
}
~~~

## 静态内部类

线程安全、兼备了高并发和延迟加载优势(有懒加载)。

~~~java
package com.tiger.singleton;

/**
 * 饿汉式单例设计模式特点：线程安全、调用效率高、资源利用率低(无懒加载)。
 *
 * @author tiger
 * @Date 2017年9月2日
 */
public class SingletonStaticInnerClass {
    /**
     * 私有化构造器，杜绝反射机制破坏
     */
    private SingletonStaticInnerClass() {
        if (LazyHolder.LAZY != null) {
            throw new RuntimeException("不允许创建多个实例");
        }
    }

    /**
     * 在静态内部类里创建类的实例
     */
    private static class LazyHolder {
        private static final SingletonStaticInnerClass LAZY = new SingletonStaticInnerClass();
    }

    /**
     * 提供一个外界调用的公共方法，需要调用的时候才会初始化静态内部类，不需要线程同步，从而兼备了高并发需求
     *
     * @return
     */
    public static SingletonStaticInnerClass getInstance() {
        //在返回结果以前，一定会先加载内部类
        return LazyHolder.LAZY;
    }
}
~~~

## 注册单例

### 枚举，天然单例

~~~java
package com.tiger.singleton;

/**
 * @description:
 * @author: tiger
 * @create: 2020-08-16 14:12
 */
public enum SingletonEnum {

    /**
     * 实例
     */
    INSTANCE;

    /**
     * 数据
     */
    Object data;

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public static SingletonEnum getInstance() {
        return INSTANCE;
    }
}

~~~

### 容器注册单例

每个对象都缓存到统一的容器中，使用唯一标识获取实例

~~~java
package com.tiger.singleton;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by tiger.
 */
public class SingletonContainer {

   private static Object INSTANCE = null;

    private SingletonContainer(){ }

    private static Map<String,Object> IOC = new ConcurrentHashMap<>();

    public static <T> T getInstance(String className){
        if(!IOC.containsKey(className)){
            try {
                //通过全路径创建实例
                INSTANCE = Class.forName(className).newInstance();
                IOC.put(className, INSTANCE);
            }catch (Exception e){
                e.printStackTrace();
            }
            return (T) INSTANCE;
        }else{
            return (T) IOC.get(className);
        }
    }

    //防止被反序列化破坏单例
    private Object readResolve(){ return INSTANCE;}
}

~~~

# 线程单例

~~~java
package com.tiger.singleton;

/**
 * @description:
 * @author: tiger
 * @create: 2020-08-20 00:02
 */
public class SingletonThreadLocal {
    private static final ThreadLocal<SingletonThreadLocal> threadLocaLInstance =
            ThreadLocal.withInitial(SingletonThreadLocal::new);

    private SingletonThreadLocal(){}

    public static SingletonThreadLocal getInstance(){
        return threadLocaLInstance.get();
    }
}

~~~

## 总结

枚举可以天然防止反射和反序列化漏洞需要延时加载时：枚举好于饿汉式 ,不需要延时加载：静态内部类好于懒汉式 也就是说优先选用 **枚举和静态内部类**。

# 原型模式

## 应用场景

1. 类初始化消耗资源多
2. new 产生一个对象需要非常繁琐的工作
3. 构造函数比较复杂
4. 循环体内产生大量对象
5. 

  

  

  

  
